/****************************************************************************************************************/
//                    0x03:    modbus_ask03    和   modbus_read03
//                    0x05:    modbus_set05    和   modbus_read05
//                    0x06:    modbus_set06    和   modbus_read06
//                    0x10:    modbus_set16    和   modbus_read16
//
//                    作为从站，只用2个函数,只适合0x03,0x05,0x06,0x10：
//                    modbus_listen   和   modbus_reply   和   modbus_err_reply
/****************************************************************************************************************/
#ifndef _MODBUS_H_
#define _MODBUS_H_

#include "main.h"

// ERROR CODE---MODBUS通信超限错误代码
#define MODBUS_NO_ERR		0x00
#define EXCEPTION_CODE_1	0x01
#define EXCEPTION_CODE_2	0x02
#define EXCEPTION_CODE_3	0x03
#define EXCEPTION_CODE_4	0x04

#define modbus0_send_byte UART0_SendByte				//(uint8 dat)
#define modbus0_send_str  UART0_SendStr					//(unsigned char str[],unsigned char k)	//发送函数需要传递数组的第一个元素地址和发送的字节数
#define modbus0_temp      uart0_temp					//UART的缓存

#define modbus1_send_byte UART1_SendByte				//(uint8 dat)
#define modbus1_send_str  UART1_SendStr					//(unsigned char str[],unsigned char k)	//发送函数需要传递数组的第一个元素地址和发送的字节数
#define modbus1_temp      uart1_temp					//UART的缓存

#define modbus2_send_byte UART2_SendByte				//(uint8 dat)
#define modbus2_send_str  UART2_SendStr					//(unsigned char str[],unsigned char k)	//发送函数需要传递数组的第一个元素地址和发送的字节数
#define modbus2_temp      uart2_temp					//UART的缓存

#define modbus3_send_byte UART3_SendByte				//(uint8 dat)
#define modbus3_send_str  UART3_SendStr					//(unsigned char str[],unsigned char k)	//发送函数需要传递数组的第一个元素地址和发送的字节数
#define modbus3_temp      uart3_temp					//UART的缓存

//modbus的数据存储区
extern uint8 modbus0_buf[MAX_BUFFER_SIZE0];				//2字节为一寄存器值，高位在前，比如modbus_buffer[0]表示寄存器1的高位，modbus_buffer[1]表示寄存器1的低位
extern uint8 modbus1_buf[MAX_BUFFER_SIZE1];				//2字节为一寄存器值，高位在前，比如modbus_buffer[0]表示寄存器1的高位，modbus_buffer[1]表示寄存器1的低位
extern uint8 modbus2_buf[MAX_BUFFER_SIZE2];				//2字节为一寄存器值，高位在前，比如modbus_buffer[0]表示寄存器1的高位，modbus_buffer[1]表示寄存器1的低位
extern uint8 modbus3_buf[MAX_BUFFER_SIZE3];				//2字节为一寄存器值，高位在前，比如modbus_buffer[0]表示寄存器1的高位，modbus_buffer[1]表示寄存器1的低位


//******************************************************************************************************
//*                                              MOBUS0                                                *
//*                                           ====从站====                                             *
//******************************************************************************************************
//从站监听主站，返回1表示成功监听到一个有效帧，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 从站地址
//func_code:  返回的功能码
//sub_addr:   返回的从站的寄存器子地址
//rw_num:     返回的读写寄存器的个数
//buf:        如果是主站写命令，则成功返回表示保存一段写的数据区
//out_time:   需要等待的最长时间
//mod_err:    modbus超限错误代码
uint8 modbus0_listen(uint8 slave_addr, uint8 *func_code, uint16 *sub_addr, uint16 *rw_num, uint8 *buf, uint16 out_time, uint8 *mod_err);

//从站回复主站
//slave_addr: 从站地址
//func_code:  功能码
//sub_addr:   回复的寄存器地址
//rw_num:     回复的寄存器的个数
//buf:        需要回复主站的寄存器值数据块地址
void modbus0_reply(uint8 slave_addr, uint8 func_code, uint16 sub_addr, uint16 rw_num, uint8 *buf);

//从站超限错误代码回复
//slave_addr: 从站地址
//func_code:  功能码
//modbus_err: 限错误代码
void modbus0_err_reply(uint8 slave_addr, uint8 func_code, uint8 modbus_err);



//******************************************************************************************************
//*                                              MOBUS1                                                *
//*                                           ====从站====                                             *
//******************************************************************************************************
//从站监听主站，返回1表示成功监听到一个有效帧，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 从站地址
//func_code:  返回的功能码
//sub_addr:   返回的从站的寄存器子地址
//rw_num:     返回的读写寄存器的个数
//buf:        如果是主站写命令，则成功返回表示保存一段写的数据区
//out_time:   需要等待的最长时间
//mod_err:    modbus超限错误代码
uint8 modbus1_listen(uint8 slave_addr, uint8 *func_code, uint16 *sub_addr, uint16 *rw_num, uint8 *buf, uint16 out_time, uint8 *mod_err);

//从站回复主站
//slave_addr: 从站地址
//func_code:  功能码
//sub_addr:   回复的寄存器地址
//rw_num:     回复的寄存器的个数
//buf:        需要回复主站的寄存器值数据块地址
void modbus1_reply(uint8 slave_addr, uint8 func_code, uint16 sub_addr, uint16 rw_num, uint8 *buf);

//从站超限错误代码回复
//slave_addr: 从站地址
//func_code:  功能码
//modbus_err: 限错误代码
void modbus1_err_reply(uint8 slave_addr, uint8 func_code, uint8 modbus_err);



//******************************************************************************************************
//*                                              MOBUS2                                                *
//*                                           ====从站====                                             *
//******************************************************************************************************
//从站监听主站，返回1表示成功监听到一个有效帧，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 从站地址
//func_code:  返回的功能码
//sub_addr:   返回的从站的寄存器子地址
//rw_num:     返回的读写寄存器的个数
//buf:        如果是主站写命令，则成功返回表示保存一段写的数据区
//out_time:   需要等待的最长时间
//mod_err:    modbus超限错误代码
uint8 modbus2_listen(uint8 slave_addr, uint8 *func_code, uint16 *sub_addr, uint16 *rw_num, uint8 *buf, uint16 out_time, uint8 *mod_err);

//从站回复主站
//slave_addr: 从站地址
//func_code:  功能码
//sub_addr:   回复的寄存器地址
//rw_num:     回复的寄存器的个数
//buf:        需要回复主站的寄存器值数据块地址
void modbus2_reply(uint8 slave_addr, uint8 func_code, uint16 sub_addr, uint16 rw_num, uint8 *buf);

//从站超限错误代码回复
//slave_addr: 从站地址
//func_code:  功能码
//modbus_err: 限错误代码
void modbus2_err_reply(uint8 slave_addr, uint8 func_code, uint8 modbus_err);



//******************************************************************************************************
//*                                              MOBUS3                                                *
//*                                           ====从站====                                             *
//******************************************************************************************************
//从站监听主站，返回1表示成功监听到一个有效帧，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 从站地址
//func_code:  返回的功能码
//sub_addr:   返回的从站的寄存器子地址
//rw_num:     返回的读写寄存器的个数
//buf:        如果是主站写命令，则成功返回表示保存一段写的数据区
//out_time:   需要等待的最长时间
//mod_err:    modbus超限错误代码
uint8 modbus3_listen(uint8 slave_addr, uint8 *func_code, uint16 *sub_addr, uint16 *rw_num, uint8 *buf, uint16 out_time, uint8 *mod_err);

//从站回复主站
//slave_addr: 从站地址
//func_code:  功能码
//sub_addr:   回复的寄存器地址
//rw_num:     回复的寄存器的个数
//buf:        需要回复主站的寄存器值数据块地址
void modbus3_reply(uint8 slave_addr, uint8 func_code, uint16 sub_addr, uint16 rw_num, uint8 *buf);

//从站超限错误代码回复
//slave_addr: 从站地址
//func_code:  功能码
//modbus_err: 限错误代码
void modbus3_err_reply(uint8 slave_addr, uint8 func_code, uint8 modbus_err);




//******************************************************************************************************
//*                                              MOBUS0                                                *
//*                                           ====主站====                                             *
//******************************************************************************************************
//******************************************************************************************************
//******************************************************************************************************
//主站询问从站[03功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址(起始地址)
//reg_num:    询问寄存器的个数
void modbus0_ask03(uint8 slave_addr, uint16 sub_addr, uint16 reg_num);

//主站接收从站[03功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 询问的从站地址
//reg_num:    询问寄存器的个数
//buf:        更新成功后返回的modbus数据区
//out_time：  需要等待的最长时间
uint8 modbus0_read03(uint8 slave_addr, uint16 sub_addr, uint16 reg_num, uint8 *buf, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[05功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值(0xFF00 or 0x0000)
void modbus0_set05(uint8 slave_addr, uint16 sub_addr, uint16 reg_value);

//从站回复主站[05功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_value:  需要返回的寄存器值，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus0_read05(uint8 slave_addr, uint16 sub_addr, uint16 reg_value, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[06功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值
void modbus0_set06(uint8 slave_addr, uint16 sub_addr, uint16 reg_value);

//从站回复主站[06功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_value:  需要返回的寄存器值，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus0_read06(uint8 slave_addr, uint16 sub_addr, uint16 reg_value, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[16功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值
//reg_num:    询问寄存器的个数
//reg_value_buf:连续设置的寄存器数组
void modbus0_set16(uint8 slave_addr, uint16 sub_addr,uint16 reg_num, uint8 *reg_value_buf);

//从站回复主站[16功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_num:    需要返回的寄存器的个数，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus0_read16(uint8 slave_addr, uint16 sub_addr, uint16 reg_num, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************



//******************************************************************************************************
//*                                              MOBUS1                                                *
//*                                           ====主站====                                             *
//******************************************************************************************************
//******************************************************************************************************
//******************************************************************************************************
//主站询问从站[03功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址(起始地址)
//reg_num:    询问寄存器的个数
void modbus1_ask03(uint8 slave_addr, uint16 sub_addr, uint16 reg_num);

//主站接收从站[03功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 询问的从站地址
//reg_num:    询问寄存器的个数
//buf:        更新成功后返回的modbus数据区
//out_time：  需要等待的最长时间
uint8 modbus1_read03(uint8 slave_addr, uint16 sub_addr, uint16 reg_num, uint8 *buf, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[05功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值(0xFF00 or 0x0000)
void modbus1_set05(uint8 slave_addr, uint16 sub_addr, uint16 reg_value);

//从站回复主站[05功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_value:  需要返回的寄存器值，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus1_read05(uint8 slave_addr, uint16 sub_addr, uint16 reg_value, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[06功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值
void modbus1_set06(uint8 slave_addr, uint16 sub_addr, uint16 reg_value);

//从站回复主站[06功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_value:  需要返回的寄存器值，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus1_read06(uint8 slave_addr, uint16 sub_addr, uint16 reg_value, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[16功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值
//reg_num:    询问寄存器的个数
//reg_value_buf:连续设置的寄存器数组
void modbus1_set16(uint8 slave_addr, uint16 sub_addr,uint16 reg_num, uint8 *reg_value_buf);

//从站回复主站[16功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_num:    需要返回的寄存器的个数，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus1_read16(uint8 slave_addr, uint16 sub_addr, uint16 reg_num, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************



//******************************************************************************************************
//*                                              MOBUS2                                                *
//*                                           ====主站====                                             *
//******************************************************************************************************
//******************************************************************************************************
//******************************************************************************************************
//主站询问从站[03功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址(起始地址)
//reg_num:    询问寄存器的个数
void modbus2_ask03(uint8 slave_addr, uint16 sub_addr, uint16 reg_num);

//主站接收从站[03功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 询问的从站地址
//reg_num:    询问寄存器的个数
//buf:        更新成功后返回的modbus数据区
//out_time：  需要等待的最长时间
uint8 modbus2_read03(uint8 slave_addr, uint16 sub_addr, uint16 reg_num, uint8 *buf, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[05功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值(0xFF00 or 0x0000)
void modbus2_set05(uint8 slave_addr, uint16 sub_addr, uint16 reg_value);

//从站回复主站[05功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_value:  需要返回的寄存器值，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus2_read05(uint8 slave_addr, uint16 sub_addr, uint16 reg_value, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[06功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值
void modbus2_set06(uint8 slave_addr, uint16 sub_addr, uint16 reg_value);

//从站回复主站[06功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_value:  需要返回的寄存器值，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus2_read06(uint8 slave_addr, uint16 sub_addr, uint16 reg_value, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[16功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值
//reg_num:    询问寄存器的个数
//reg_value_buf:连续设置的寄存器数组
void modbus2_set16(uint8 slave_addr, uint16 sub_addr,uint16 reg_num, uint8 *reg_value_buf);

//从站回复主站[16功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_num:    需要返回的寄存器的个数，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus2_read16(uint8 slave_addr, uint16 sub_addr, uint16 reg_num, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************



//******************************************************************************************************
//*                                              MOBUS3                                                *
//*                                           ====主站====                                             *
//******************************************************************************************************
//******************************************************************************************************
//******************************************************************************************************
//主站询问从站[03功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址(起始地址)
//reg_num:    询问寄存器的个数
void modbus3_ask03(uint8 slave_addr, uint16 sub_addr, uint16 reg_num);

//主站接收从站[03功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 询问的从站地址
//reg_num:    询问寄存器的个数
//buf:        更新成功后返回的modbus数据区
//out_time：  需要等待的最长时间
uint8 modbus3_read03(uint8 slave_addr, uint16 sub_addr, uint16 reg_num, uint8 *buf, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[05功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值(0xFF00 or 0x0000)
void modbus3_set05(uint8 slave_addr, uint16 sub_addr, uint16 reg_value);

//从站回复主站[05功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_value:  需要返回的寄存器值，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus3_read05(uint8 slave_addr, uint16 sub_addr, uint16 reg_value, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[06功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值
void modbus3_set06(uint8 slave_addr, uint16 sub_addr, uint16 reg_value);

//从站回复主站[06功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_value:  需要返回的寄存器值，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus3_read06(uint8 slave_addr, uint16 sub_addr, uint16 reg_value, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


//******************************************************************************************************
//******************************************************************************************************
//主站设置从站[16功能码]
//slave_addr: 从站地址
//sub_addr：  从站的寄存器子地址
//reg_value:  设置寄存器的值
//reg_num:    询问寄存器的个数
//reg_value_buf:连续设置的寄存器数组
void modbus3_set16(uint8 slave_addr, uint16 sub_addr,uint16 reg_num, uint8 *reg_value_buf);

//从站回复主站[16功能码]
//更新MODBUS的数据区，返回1表示更新成功，0表示数据错误，没有更新,该函数里面已包含OSDELAY
//slave_addr: 需要返回的从站地址，返回此值表明正确
//sub_addr:   需要返回的从站寄存器地址，返回此值表明正确
//reg_num:    需要返回的寄存器的个数，返回此值表明正确
//out_time：  需要等待的最长时间
uint8 modbus3_read16(uint8 slave_addr, uint16 sub_addr, uint16 reg_num, uint16 out_time);
//******************************************************************************************************
//******************************************************************************************************


#endif
